\documentclass[a4paper]{scrartcl}

\usepackage[english]{babel}
\usepackage[a4paper]{geometry}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{url}
\usepackage{proof}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstnewenvironment{code}
    {\lstset{}%
      \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}
    \lstset{
      basicstyle=\small\ttfamily,
      language=haskell,
      flexiblecolumns=false,
      basewidth={0.5em,0.45em},
      literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2 
               {\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
               {>>}{{>>}}2 {>>=}{{>>=}}2
               {|}{{$\mid$}}1               
    }

\newcommand{\hsterm}[1]{%
    \setlength{\fboxsep}{3pt}%
    \setlength{\fboxrule}{0.2pt}%
    \fbox{\texttt{#1}}}
\renewcommand{\vec}[1]{\overline{#1}}

\title{Control Flow Analysis of monomorphic Haskell}
\author{Stijn van Drongelen {\tiny(3117537)},
        Tom Tervoort {\tiny(3470784)},
        Gerben van Veenendaal {\tiny(3460692)}}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
\section{Goal}
% TODO

To implement CFA on a subset of Haskell. Since we use \texttt{haskell-src} to
parse, this is already a huge scope limiting factor. We further narrow it
down to mainly just functions and data types. In other words, we don't
support:

\begin{description}
\item[Recursive let-bindings]
    TODO
\item[Type signatures]
    Although type signatures shouldn't be too hard to support, we choose
    not to do this. The extra code required to connect a type signature to
    the corresponding binding is not worth it, given that the other restrictions
    on our subset make type inference decidable.
\item[Guards]
    Having to deal with guards makes the process of simplifying \texttt{case}
    constructs very hard. We choose not to support them.
\item[Type classes]
    Type classes require a lot of extra work in the type inference algorithm.
\item[Literals]
    Numeric literals (and with certain extensions, \texttt{String} as well)
    are polymorphic with a type class restriction. Since we don't support type
    classes, we can't support literals.
\item[Do-notation]
    The \texttt{do}-notation desugars to the use of operators from the \texttt{Monad}
    type class, and we can't support them.
\item[List comprehensions]
    List comprehensions can be seen as limited forms of the \texttt{do}-notation.
    We could support them, but since not much more interesting than other
    features of the language, we choose not to.
\item [Modules (and imports)]
    Most examples of control flow analysis fit in a single module. Although
    analysis beyond module boundaries might be interesting, we simply don't
    have the time to implement proper support for modules.
\item [Foreign function interface]
    Supporting the FFI is even harder than supporting imports. We simply don't
    do this.
\end{description}

Furthermore, we initially choose to perform a monomorphic, monovariant analysis.

\section{The language}
We consider a desugared form of Haskell 2010.

\begin{code}
data Term = LiteralTerm     {literal :: Literal}
          | VariableTerm    {varName :: Name}
          | ApplicationTerm {lhsTerm :: Term, rhsTerm :: Term}
          | AbstractionTerm {argName :: Name, bodyTerm :: Term}
          | LetInTerm       {letTerm :: (Name, Term), inTerm :: Term}
          | CaseTerm        {exprTerm :: Term, alts :: [(Pattern, Term)]}
          | ListTerm        {terms :: [Term]}
          | TupleTerm       {terms :: [Term]}
          | FixTerm         {fixedTerm :: Term}

data Pattern = Variable Name
             | Pattern {ctorName :: Name, ctorArgs :: [Name]}

type Name = String

data Literal = IntegralLit Integer
             | FractionalLit Rational
             | StringLit String
             | CharLit Char
\end{code}

\subsection{Type rules}
The type universe is as follows:

\begin{code}
data Type = BasicType BasicType
          | DataType Name
          | ListType Type
          | TupleType [Type]
          | Arrow (Maybe AnnVar) Type Type
          | TyVar Name

data BasicType = Integer
               | Char
               | Double

type AnnVar = Name
\end{code}

Types of literals:
\begin{align*}
\infer[LitIntegral]%
    {\Gamma \vdash \hsterm{LiteralTerm (IntegerLit \_)} : \hsterm{BasicType Integer}}%
    {}\\
\infer[LitChar]%
    {\Gamma \vdash \hsterm{LiteralTerm (CharLit \_)} : \hsterm{BasicType Char}}%
    {}\\
\infer[LitString]%
    {\Gamma \vdash \hsterm{LiteralTerm (StringLit \_)} : \hsterm{ListType (BasicType Char)}}%
    {}\\
\infer[LitFractional]%
    {\Gamma \vdash \hsterm{LiteralTerm (FractionalLit \_)} : \hsterm{BasicType Double}}%
    {}\\
\end{align*}

Hardwired type constructors:
\begin{align*}
\infer[ListIntro]%
    {\Gamma \vdash \hsterm{ListTerm \ensuremath{\vec{e}}} : \hsterm{ListType \ensuremath{a}}}%
    {\forall e \in \vec{e}. \Gamma \vdash e : a}\\
\infer[TupleIntro]%
    {\Gamma \vdash \hsterm{TupleTerm \ensuremath{\vec{e}}} : \hsterm{TupleType \ensuremath{\vec{a}}}}%
    {\forall (e,a) \in \vec{e}\times\vec{a}. \Gamma \vdash e : a}
\end{align*}

Declaration:
\begin{align*}
\infer[LetIn]%
    {\Gamma \vdash \hsterm{LetInTerm (\ensuremath{x}, \ensuremath{e_1}) \ensuremath{e_0}} : \tau_0}%
    {\Gamma \vdash e_1 : \tau_1 \qquad \Gamma [x : \tau_1] \vdash e_0 : \tau_0}
\end{align*}

Abstraction and application:
\begin{align*}
\infer[FunIntro]%
    {\Gamma \vdash \hsterm{AbstractionTerm \ensuremath{x} \ensuremath{e}} : \hsterm{Arrow \_ \ensuremath{\tau_x} \ensuremath{\tau_e}}}%
    {\Gamma [x : \tau_x] \vdash e : \tau_e}\\
\infer[FunElim]%
    {\Gamma \vdash \hsterm{ApplicationTerm \ensuremath{e_0} \ensuremath{e_1}} : \tau_2}%
    {\Gamma \vdash e_0 : \hsterm{Arrow \_ \ensuremath{\tau_1} \ensuremath{\tau_2}} \qquad \Gamma \vdash e_1 : \tau_1}
\end{align*}

Fixpoint:
\begin{align*}
\infer[FunFix]%
    {\Gamma \vdash \hsterm{FixTerm \ensuremath{e}} : \ensuremath{a}}%
    {\Gamma \vdash \ensuremath{e} : \hsterm{Arrow \_ (Arrow \_ \ensuremath{a} \ensuremath{a}) \ensuremath{a}}}
\end{align*}

Case matching:
\begin{align*}
\infer[DataElim]%
    {\Gamma \vdash \hsterm{CaseTerm \ensuremath{s} \ensuremath{\vec{m}}} : \tau_e}%
    {\Gamma \vdash s : \tau_s \qquad
    \forall \hsterm{(\ensuremath{p}, \ensuremath{e})} \in \vec{m}.\left(
        \Gamma \vdash_\textsc{Patt} p : \tau_s \& b \qquad
        \Gamma; b \vdash e : \tau_e
    \right)}
\end{align*}

\subsubsection{Pattern typing}
\subsubsection{Administrative rules}
% TODO rules regarding \Gamma
% TODO rules regarding subtyping/whatever

\section{The analysis}
% TODO leveraging type inference to perform CFA

\section{Implementation}
\section{Results}
\section{Discussion}
\begin{itemize}
\item
    We treat lists and tuples as special types. A different approach might
    have resulted in less redundant code.
\end{itemize}

\section{Conclusion}

\end{document}
