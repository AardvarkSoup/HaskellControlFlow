\documentclass[a4paper]{scrartcl}

\usepackage[english]{babel}
\usepackage[a4paper]{geometry}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{url}
\usepackage{proof}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstnewenvironment{code}
    {\lstset{}%
      \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}
    \lstset{
      basicstyle=\small\ttfamily,
      language=haskell,
      flexiblecolumns=false,
      basewidth={0.5em,0.45em},
      literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2 
               {\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
               {>>}{{>>}}2 {>>=}{{>>=}}2
               {|}{{$\mid$}}1               
    }

\newcommand{\hsterm}[1]{%
    \setlength{\fboxsep}{3pt}%
    \setlength{\fboxrule}{0.2pt}%
    \fbox{\texttt{#1}}}
\renewcommand{\vec}[1]{\overline{#1}}

\title{Control Flow Analysis of monomorphic Haskell}
\author{Stijn van Drongelen {\tiny(3117537)},
        Tom Tervoort {\tiny(3470784)},
        Gerben van Veenendaal {\tiny(3460692)}}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
\section{Goal}
The goal of this project is to implement CFA on a small subset of Haskell.
We use \texttt{haskell-src}, so we can only deal with Haskell 98 to begin with,
but that's still a language with more features than we can handle.

\begin{description}
\item[No guards]
    Having to deal with guards makes processing \texttt{case} constructs very
    hard. We choose not to support them, and as a consequence, we also don't
    use them in our examples.
\item[No type classes]
    Type classes would require a lot of extra work in the type inference
    algorithm.
\item[No type signatures]
    Type inference on Haskell 98 is decidable, and we don't have to resolve
    ambiguous types due to our lack of type classes, so it's not really worth
    implementing support for type signatures.
\item[Monomorphic literals]
    Literals (at least the numeric ones) are polymorphic in Haskell 98, with
    a type class restriction. Since we can't use type classes, we make literals
    monomorphic instead.
\item[No do-notation or list comprehensions]
    These constructs are pure syntactic sugar. We don't use them in our examples,
    so we don't bother to implement a desugaring for them.
\item[No modularity]
    Since our examples fit in a single module, we don't implement module imports
    or exports (let alone the FFI).
\end{description}

\section{The language}
We consider a desugared form of Haskell 98.

\begin{code}
data Term = LiteralTerm     {literal :: Literal}
          | VariableTerm    {varName :: Name}
          | ApplicationTerm {lhsTerm :: Term, rhsTerm :: Term}
          | AbstractionTerm {argName :: Name, bodyTerm :: Term}
          | LetInTerm       {letTerm :: (Name, Term), inTerm :: Term}
          | CaseTerm        {exprTerm :: Term, alts :: [(Pattern, Term)]}
          | ListTerm        {terms :: [Term]}
          | TupleTerm       {terms :: [Term]}
          | FixTerm         {fixedTerm :: Term}

data Pattern = Variable Name
             | Pattern {ctorName :: Name, ctorArgs :: [Name]}

type Name = String

data Literal = IntegralLit Integer
             | FractionalLit Rational
             | StringLit String
             | CharLit Char
\end{code}

\subsection{Type rules}
The type universe is as follows:

\begin{code}
data Type = BasicType BasicType
          | DataType Name
          | ListType Type
          | TupleType [Type]
          | Arrow (Maybe AnnVar) Type Type
          | TyVar Name

data BasicType = Integer
               | Char
               | Double

type AnnVar = Name
\end{code}

Types of literals:
\begin{align*}
\infer[LitIntegral]%
    {\Gamma \vdash \hsterm{LiteralTerm (IntegerLit \_)} : \hsterm{BasicType Integer}}%
    {}\\
\infer[LitChar]%
    {\Gamma \vdash \hsterm{LiteralTerm (CharLit \_)} : \hsterm{BasicType Char}}%
    {}\\
\infer[LitString]%
    {\Gamma \vdash \hsterm{LiteralTerm (StringLit \_)} : \hsterm{ListType (BasicType Char)}}%
    {}\\
\infer[LitFractional]%
    {\Gamma \vdash \hsterm{LiteralTerm (FractionalLit \_)} : \hsterm{BasicType Double}}%
    {}\\
\end{align*}

Hardwired type constructors:
\begin{align*}
\infer[ListIntro]%
    {\Gamma \vdash \hsterm{ListTerm \ensuremath{\vec{e}}} : \hsterm{ListType \ensuremath{a}}}%
    {\forall e \in \vec{e}. \Gamma \vdash e : a}\\
\infer[TupleIntro]%
    {\Gamma \vdash \hsterm{TupleTerm \ensuremath{\vec{e}}} : \hsterm{TupleType \ensuremath{\vec{a}}}}%
    {\forall (e,a) \in \vec{e}\times\vec{a}. \Gamma \vdash e : a}
\end{align*}

Declaration:
\begin{align*}
\infer[LetIn]%
    {\Gamma \vdash \hsterm{LetInTerm (\ensuremath{x}, \ensuremath{e_1}) \ensuremath{e_0}} : \tau_0}%
    {\Gamma \vdash e_1 : \tau_1 \qquad \Gamma [x : \tau_1] \vdash e_0 : \tau_0}
\end{align*}

Abstraction and application:
\begin{align*}
\infer[FunIntro]%
    {\Gamma \vdash \hsterm{AbstractionTerm \ensuremath{x} \ensuremath{e}} : \hsterm{Arrow \_ \ensuremath{\tau_x} \ensuremath{\tau_e}}}%
    {\Gamma [x : \tau_x] \vdash e : \tau_e}\\
\infer[FunElim]%
    {\Gamma \vdash \hsterm{ApplicationTerm \ensuremath{e_0} \ensuremath{e_1}} : \tau_2}%
    {\Gamma \vdash e_0 : \hsterm{Arrow \_ \ensuremath{\tau_1} \ensuremath{\tau_2}} \qquad \Gamma \vdash e_1 : \tau_1}
\end{align*}

Fixpoint:
\begin{align*}
\infer[FunFix]%
    {\Gamma \vdash \hsterm{FixTerm \ensuremath{e}} : \ensuremath{a}}%
    {\Gamma \vdash \ensuremath{e} : \hsterm{Arrow \_ (Arrow \_ \ensuremath{a} \ensuremath{a}) \ensuremath{a}}}
\end{align*}

Case matching:
\begin{align*}
\infer[DataElim]%
    {\Gamma \vdash \hsterm{CaseTerm \ensuremath{s} \ensuremath{\vec{m}}} : \tau_e}%
    {\Gamma \vdash s : \tau_s \qquad
    \forall \hsterm{(\ensuremath{p}, \ensuremath{e})} \in \vec{m}.\left(
        \Gamma \vdash_\textsc{Patt} p : \tau_s \& b \qquad
        \Gamma; b \vdash e : \tau_e
    \right)}
\end{align*}

\subsubsection{Pattern typing}
\subsubsection{Administrative rules}
% TODO rules regarding \Gamma
% TODO rules regarding subtyping/whatever

\section{The analysis}
% TODO leveraging type inference to perform CFA

\section{Implementation}
\section{Results}
\section{Discussion}
\begin{itemize}
\item
    We treat lists and tuples as special types. A different approach might
    have resulted in less redundant code.
\end{itemize}

\section{Conclusion}

\end{document}
