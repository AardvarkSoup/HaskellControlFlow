\documentclass[a4paper]{scrartcl}

\usepackage[english]{babel}
\usepackage[a4paper]{geometry}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{url}
\usepackage{proof}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstnewenvironment{code}
    {\lstset{}%
      \csname lst@SetFirstLabel\endcsname}
    {\csname lst@SaveFirstLabel\endcsname}
    \lstset{
      basicstyle=\small\ttfamily,
      language=haskell,
      flexiblecolumns=false,
      basewidth={0.5em,0.45em},
      literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
               {\\\\}{{\char`\\\char`\\}}1
               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2 
               {\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
               {>>}{{>>}}2 {>>=}{{>>=}}2
               {|}{{$\mid$}}1               
    }

\newcommand{\hsterm}[1]{%
    \setlength{\fboxsep}{3pt}%
    \setlength{\fboxrule}{0.2pt}%
    \fbox{\texttt{\small #1}}}
\renewcommand{\vec}[1]{\overline{#1}}

\newcommand{\algow}{algorithm~$\mathcal{W}$}

\DeclareMathOperator{\zip}{zip}
\DeclareMathOperator{\curry}{curry}

\title{Control Flow Analysis of monomorphic Haskell}
\author{Stijn van Drongelen {\tiny(3117537)},
        Tom Tervoort {\tiny(3470784)},
        Gerben van Veenendaal {\tiny(3460692)}}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
The goal of this project is to implement CFA on a small subset of Haskell.
We use \texttt{haskell-src}, so we can only deal with Haskell 98 to begin with,
but that's still a language with more features than we can handle.

\begin{description}
\item[No guards]
    Having to deal with guards makes processing \texttt{case} constructs very
    hard. We choose not to support them, and as a consequence, we also don't
    use them in our examples.
\item[No type classes]
    Type classes would require a lot of extra work in the type inference
    algorithm.
\item[No type signatures]
    Type inference on Haskell 98 is decidable, and we don't have to resolve
    ambiguous types due to our lack of type classes, so it's not really worth
    implementing support for type signatures.
\item[Monomorphic literals]
    Literals (at least the numeric ones) are polymorphic in Haskell 98, with
    a type class restriction. Since we can't use type classes, we make literals
    monomorphic instead.
\item[Monomorphic types]
    Our subset of Haskell is not polymorphic.
\item[No do-notation or list comprehensions]
    These constructs are pure syntactic sugar. We don't use them in our examples,
    so we don't bother to implement a desugaring for them.
\item[No modularity]
    Since our examples each fit in a single module, we don't implement module
    imports or exports (let alone the FFI).
\end{description}

\section{The language}
Every module is assumed to define a function \texttt{main}. Under this
assumption, we build a \texttt{Term} which expresses the value of this
function:

\begin{code}
data Term = LiteralTerm     Literal
          | VariableTerm    Name
          | HardwiredTerm   HardwiredValue
          | ApplicationTerm Term Term
          | AbstractionTerm Name Term
          | LetInTerm       Name Term Term
          | CaseTerm        Term [(Pattern, Term)]
          | FixTerm         Term

data Literal = IntegralLit Integer
             | FractionalLit Rational
             | StringLit String
             | CharLit Char

data HardwiredValue = HwTupleCon Int 
                    | HwListCons
                    | HwListNil

data Pattern = Variable Name
             | Pattern {ctorName :: Name, ctorArgs :: [Name]}
\end{code}

Note that, even though \texttt{LetInTerm} is much more simplistic than
Haskell's let-bindings, it is sufficient due to the inclusion of a least
fixed point operator (\texttt{FixTerm}), which serves the same purpose as
\texttt{fix} from \texttt{Data.Function}.

Also note the absence of data type definitions. They are supported in our
language, but are parsed and treated separately (the constructors are
inserted immediately into the environment).

\subsection{Type rules}
The type universe of our language is defined by the following data types:

\begin{code}
data Type = BasicType BasicType
          | DataType Name
          | ListType Type
          | TupleType [Type]
          | Arrow (Maybe AnnVar) Type Type
          | TyVar Name

data BasicType = Integer
               | Char
               | Double

type AnnVar = Name
\end{code}

We will ignore the \texttt{Maybe AnnVar} field of the \texttt{Arrow} constructor
for now.

Note the lack of a \texttt{Forall} (or System F-style \texttt{TyLambda})
construct: we don't support polymorphism, and the \texttt{TyVar}s are
only there to aid \algow{}.

For sake of space, we omit the rules for defining the environment and
type instantiation.

\subsubsection{Type rules for terms}
Variables:
\begin{equation*}
\infer[Var]%
    {\Gamma \vdash \hsterm{VariableTerm \ensuremath{x}} : \tau}
    {\Gamma(x) = \tau}
\end{equation*}

The rules for the hardwired types (literals, lists, and tuples) are axioms
and simple recursive rules:
\begin{equation*}
\infer[LitIntegral]%
    {\Gamma \vdash \hsterm{LiteralTerm (IntegerLit \_)} : \hsterm{BasicType Integer}}%
    {}
\end{equation*}\begin{equation*}
\infer[LitChar]%
    {\Gamma \vdash \hsterm{LiteralTerm (CharLit \_)} : \hsterm{BasicType Char}}%
    {}
\end{equation*}\begin{equation*}
\infer[LitString]%
    {\Gamma \vdash \hsterm{LiteralTerm (StringLit \_)} : \hsterm{ListType (BasicType Char)}}%
    {}
\end{equation*}\begin{equation*}
\infer[LitFractional]%
    {\Gamma \vdash \hsterm{LiteralTerm (FractionalLit \_)} : \hsterm{BasicType Double}}%
    {}
\end{equation*}\begin{equation*}
\infer[TupleConIntro]%
    {\Gamma \vdash \hsterm{HardwiredTerm (HwTupleCon \ensuremath{n})} : \ldots}%
    {}
\end{equation*}\begin{equation*}
\infer[ListConsIntro]%
    {\Gamma \vdash \hsterm{HardwiredTerm HwListCons} : \hsterm{Arrow \_ \ensuremath{a} (Arrow \_ (ListType \ensuremath{a}) (ListType \ensuremath{a}))}}%
    {}
\end{equation*}\begin{equation*}
\infer[ListNilIntro]%
    {\Gamma \vdash \hsterm{HardwiredTerm HwListNil} : \hsterm{ListType \ensuremath{a}}}%
    {}
\end{equation*}

Abstraction, application, and the fixed point combinator:
\begin{equation*}
\infer[FunIntro]%
    {\Gamma \vdash \hsterm{AbstractionTerm \ensuremath{x} \ensuremath{e}} : \hsterm{Arrow \_ \ensuremath{\tau_x} \ensuremath{\tau_e}}}%
    {\Gamma [x : \tau_x] \vdash e : \tau_e}%
\end{equation*}\begin{equation*}
\infer[FunElim]%
    {\Gamma \vdash \hsterm{ApplicationTerm \ensuremath{e_0} \ensuremath{e_1}} : \tau_2}%
    {\Gamma \vdash e_0 : \hsterm{Arrow \_ \ensuremath{\tau_1} \ensuremath{\tau_2}} \qquad \Gamma \vdash e_1 : \tau_1}%
\end{equation*}\begin{equation*}
\infer[FunFix]%
    {\Gamma \vdash \hsterm{FixTerm \ensuremath{e}} : \ensuremath{a}}%
    {\Gamma \vdash \ensuremath{e} : \hsterm{Arrow \_ (Arrow \_ \ensuremath{a} \ensuremath{a}) \ensuremath{a}}}
\end{equation*}

Declarations:
\begin{align*}
\infer[LetIn]%
    {\Gamma \vdash \hsterm{LetInTerm \ensuremath{x} \ensuremath{e_1} \ensuremath{e_0}} : \tau_0}%
    {\Gamma \vdash e_1 : \tau_1 \qquad \Gamma [x : \tau_1] \vdash e_0 : \tau_0}
\end{align*}

Case matching:
\begin{align*}
\infer[DataElim]%
    {\Gamma \vdash \hsterm{CaseTerm \ensuremath{s} \ensuremath{\vec{m}}} : \tau_e}%
    {\Gamma \vdash s : \tau_s
    \qquad
    \forall \hsterm{(\ensuremath{p}, \ensuremath{e})} \in \vec{m}.\left(
        \Gamma \vdash_\textsc{Patt} p : \tau_s \& b \qquad
        \Gamma; b \vdash e : \tau_e
    \right)}
\end{align*}

\subsubsection{Type rules for patterns}
For patterns, we need slightly different judgements. Patterns don't just have
a type, but they also bind variables, for which the type should might be known.
As seen in the \textit{DataElim} rule, pattern type judgements take the form
\begin{equation*}
    \Gamma \vdash_\textsc{Patt} p : \tau \& b,
\end{equation*}
where $p$ is the pattern, $\tau$ is the type of the pattern, and $b$ is
a sequence of mappings from variables (as bound in $p$) to types (as implied
by $p$).

\begin{equation*}
\infer[VarPatt]%
    {\Gamma \vdash_\textsc{Patt} \hsterm{Variable \ensuremath{x}} : \tau \& [x : \tau]}%
    {}
\end{equation*}

\begin{equation*}
\infer[ConPatt]%
    {\Gamma \vdash_\textsc{Patt} \hsterm{Patt \ensuremath{c} \ensuremath{\vec{p}}} : \tau_t \& \bigcup \vec{b}}%
    {\Gamma \vdash c : \tau_c
    \qquad \forall (p,\tau_p,b) \in \zip(\vec{p}, \vec{\tau_p}, \vec{b}).
        \Gamma \vdash_\textsc{Patt} p : \tau_p \& b
    \qquad \text{$\vec{b}$ pairwise disjoint}}
\end{equation*}
where $(\vec{\tau_p}, \tau_t) = \curry \tau_c$.

\section{Implementation}
\subsection{Parsing and desugaring}
After reading the file and parsing it with \texttt{haskell-src}, our
implementation translates the resulting code into our limited AST type.
Part of this phase involves determining the strongly connected components
in the `dependency' graph of the functions, so that we can rewrite mutually
recursive functions in terms of the fixed point combinator.

If there's anything we encounter that we can't support, we throw an error.

\subsection{Type inference and constraint generation}
We then apply a very straightforward implementation of \algow{} to the
desugared program.

Remember the \texttt{Maybe AnnVar} field in the \texttt{Arrow} constructor;
during type inference, we plug fresh variables into these fields, and wherever
necessary, we record constraints about these variables while executing \algow{}.
The constraints are of the form $\phi \equiv \phi'$ (called
\texttt{SubstitutionConstraint} in our implementation) and $n \in \phi$
(\texttt{InclusionConstraint}).

We found that formulating constraints only made sense when declaring new
functions. As such, we only do this when we encounter a \texttt{LetInTerm}
node during type inference. When we bind an expression to a name $n$,
and we know that the expression is a function with annotation $\phi$,
we can add a constraint $n \in \phi$.

\subsection{Constraint solving}
After \algow{} is done, we solve the constraints on the annotation variables
separately. First, we build a union-find structure to express the
$\phi \equiv \phi'$ constraints. Then, for the $n \in \phi$ constraints,
we build a mapping from the representatives of $\phi$ (as found in
the union-find structure) to sets of related $n$ from the constraints.
We end up with a map from representative annotation variables to minimal sets
of function names, and a way to translate any annotation variable to its
representative.

\subsection{Output}
Finally, we print the following information:
\begin{itemize}
\item The desugared form of the input program.
\item The inferred type of the \texttt{main} function.
\item For every function application, the result of the CFA on the function.
    Specifically, only named functions are listed.
\end{itemize}

\section{Discussion}
When executing our CFA, you may notice that a lot of applications don't involve
function calls of directly named functions. This significantly reduces the
usefulness of this CFA; even information like ``an inner function of $f$''
might be very useful to the consumer of the analysis.

A few aspects of our implementation might be considered warts:
\begin{itemize}
\item
    We might have been able to use a more applicative style of programming
    if we had separated type constraint generation and solving. However,
    we already had a straightforward implementation of \algow{} available.
\end{itemize}

\end{document}
